---
description:
globs:
alwaysApply: false
---
<bug_investigation>
<issue_description>
{A concise but complete description of the persistent bug or issue. Include observed behavior, expected behavior, and any relevant error messages.}
</issue_description>

<mission_briefing>
Previous, simpler attempts to resolve this issue have failed. Standard procedures are now suspended. You will initiate a **deep diagnostic protocol.**

Your approach must be systematic, evidence-based, and relentlessly focused on identifying and fixing the **absolute root cause.** Patching symptoms is a critical failure.
</mission_briefing>

<investigation_phases>
<phase_0>
## Phase 0: Reconnaissance & State Baseline (Read-Only)

<directives>
- **Directive:** Adhering to the **Operational Doctrine**, perform a non-destructive scan of the repository, runtime environment, configurations, and recent logs. Your objective is to establish a high-fidelity, evidence-based baseline of the system's current state as it relates to the anomaly.
- **Output:** Produce a concise digest (‚â§ 200 lines) of your findings.
- **Constraint:** **No mutations are permitted during this phase.**
</directives>
</phase_0>

<phase_1>
## Phase 1: Isolate the Anomaly

<directives>
- **Directive:** Your first and most critical goal is to create a **minimal, reproducible test case** that reliably and predictably triggers the bug.
<actions>
1. **Define Correctness:** Clearly state the expected, non-buggy behavior.
2. **Create a Failing Test:** If possible, write a new, specific automated test that fails precisely because of this bug. This test will become your signal for success.
3. **Pinpoint the Trigger:** Identify the exact conditions, inputs, or sequence of events that causes the failure.
</actions>
- **Constraint:** You will not attempt any fixes until you can reliably reproduce the failure on command.
</directives>
</phase_1>

<phase_2>
## Phase 2: Root Cause Analysis (RCA)

<directives>
- **Directive:** With a reproducible failure, you will now methodically investigate the failing pathway to find the definitive root cause.
<evidence_protocol>
1. **Formulate a Testable Hypothesis:** State a clear, simple theory about the cause (e.g., "Hypothesis: The user authentication token is expiring prematurely.").
2. **Devise an Experiment:** Design a safe, non-destructive test or observation to gather evidence that will either prove or disprove your hypothesis.
3. **Execute and Conclude:** Run the experiment, present the evidence, and state your conclusion. If the hypothesis is wrong, formulate a new one based on the new evidence and repeat this loop.
</evidence_protocol>

<anti_patterns>
**Anti-Patterns (Forbidden Actions):**
- **FORBIDDEN:** Applying a fix without a confirmed root cause supported by evidence.
- **FORBIDDEN:** Re-trying a previously failed fix without new data.
- **FORBIDDEN:** Patching a symptom (e.g., adding a `null` check) without understanding *why* the value is becoming `null`.
</anti_patterns>
</directives>
</phase_2>

<phase_3>
## Phase 3: Remediation

<directives>
- **Directive:** Design and implement a minimal, precise fix that durably hardens the system against the confirmed root cause.
<protocols>
**Core Protocols in Effect:**
- **Read-Write-Reread:** For every file you modify, you must read it immediately before and after the change.
- **Command Execution Canon:** All shell commands must use the mandated safety wrapper.
- **System-Wide Ownership:** If the root cause is in a shared component, you are **MANDATED** to analyze and, if necessary, fix all other consumers affected by the same flaw.
</protocols>
</directives>
</phase_3>

<phase_4>
## Phase 4: Verification & Regression Guard

<directives>
- **Directive:** Prove that your fix has resolved the issue without creating new ones.
<verification_steps>
1. **Confirm the Fix:** Re-run the specific failing test case from Phase 1. It **MUST** now pass.
2. **Run Full Quality Gates:** Execute the entire suite of relevant tests (unit, integration, etc.) and linters to ensure no regressions have been introduced elsewhere.
3. **Autonomous Correction:** If your fix introduces any new failures, you will autonomously diagnose and resolve them.
</verification_steps>
</directives>
</phase_4>

<phase_5>
## Phase 5: Mandatory Zero-Trust Self-Audit

<directives>
- **Directive:** Your remediation is complete, but your work is **NOT DONE.** You will now conduct a skeptical, zero-trust audit of your own fix.
<audit_protocol>
1. **Re-verify Final State:** With fresh commands, confirm that all modified files are correct and that all relevant services are in a healthy state.
2. **Hunt for Regressions:** Explicitly test the primary workflow of the component you fixed to ensure its overall functionality remains intact.
</audit_protocol>
</directives>
</phase_5>

<phase_6>
## Phase 6: Final Report & Verdict

<directives>
- **Directive:** Conclude your mission with a structured "After-Action Report."
<report_structure>
- **Root Cause:** A definitive statement of the underlying issue, supported by the key piece of evidence from your RCA.
- **Remediation:** A list of all changes applied to fix the issue.
- **Verification Evidence:** Proof that the original bug is fixed (e.g., the passing test output) and that no new regressions were introduced (e.g., the output of the full test suite).
<verdicts>
- **Final Verdict:** Conclude with one of the two following statements, exactly as written:
  - `"Self-Audit Complete. Root cause has been addressed, and system state is verified. No regressions identified. Mission accomplished."`
  - `"Self-Audit Complete. CRITICAL ISSUE FOUND during audit. Halting work. [Describe issue and recommend immediate diagnostic steps]."`
</verdicts>
</report_structure>
- **Constraint:** Maintain an inline TODO ledger using ‚úÖ / ‚ö†Ô∏è / üöß markers throughout the process.
</directives>
</phase_6>
</investigation_phases>
</bug_investigation>